// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: skills.sql

package dao

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSkill = `-- name: CreateSkill :exec
INSERT INTO app.skills (name,
                        youtube_video_id,
                        is_video_landscape,
                        level,
                        categories,
                        prerequisites)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateSkillParams struct {
	Name             string
	YoutubeVideoID   string
	IsVideoLandscape bool
	Level            int16
	Categories       []string
	Prerequisites    []pgtype.UUID
}

func (q *Queries) CreateSkill(ctx context.Context, arg CreateSkillParams) error {
	_, err := q.db.Exec(ctx, createSkill,
		arg.Name,
		arg.YoutubeVideoID,
		arg.IsVideoLandscape,
		arg.Level,
		arg.Categories,
		arg.Prerequisites,
	)
	return err
}

const deleteSkill = `-- name: DeleteSkill :one
DELETE
FROM app.skills
WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteSkill(ctx context.Context, id pgtype.UUID) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, deleteSkill, id)
	err := row.Scan(&id)
	return id, err
}

const getSkills = `-- name: GetSkills :many
SELECT id, name, youtube_video_id, is_video_landscape, level, categories, prerequisites, created_at, updated_at
FROM app.skills
`

func (q *Queries) GetSkills(ctx context.Context) ([]AppSkill, error) {
	rows, err := q.db.Query(ctx, getSkills)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppSkill
	for rows.Next() {
		var i AppSkill
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.YoutubeVideoID,
			&i.IsVideoLandscape,
			&i.Level,
			&i.Categories,
			&i.Prerequisites,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const skillsFingerprint = `-- name: SkillsFingerprint :one
SELECT COUNT(*)::bigint AS cnt, (COALESCE(MAX(updated_at), 'epoch'::timestamptz)) ::timestamptz AS max_updated_at
FROM app.skills
`

type SkillsFingerprintRow struct {
	Cnt          int64
	MaxUpdatedAt pgtype.Timestamptz
}

func (q *Queries) SkillsFingerprint(ctx context.Context) (SkillsFingerprintRow, error) {
	row := q.db.QueryRow(ctx, skillsFingerprint)
	var i SkillsFingerprintRow
	err := row.Scan(&i.Cnt, &i.MaxUpdatedAt)
	return i, err
}

const updateSkill = `-- name: UpdateSkill :one
UPDATE app.skills
SET name               = $2,
    youtube_video_id   = $3,
    is_video_landscape = $4,
    level              = $5,
    categories         = $6,
    prerequisites      = $7
WHERE id = $1 RETURNING id
`

type UpdateSkillParams struct {
	ID               pgtype.UUID
	Name             string
	YoutubeVideoID   string
	IsVideoLandscape bool
	Level            int16
	Categories       []string
	Prerequisites    []pgtype.UUID
}

func (q *Queries) UpdateSkill(ctx context.Context, arg UpdateSkillParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updateSkill,
		arg.ID,
		arg.Name,
		arg.YoutubeVideoID,
		arg.IsVideoLandscape,
		arg.Level,
		arg.Categories,
		arg.Prerequisites,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}
